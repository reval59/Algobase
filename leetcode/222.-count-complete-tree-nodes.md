---
description: 'https://leetcode.com/problems/count-complete-tree-nodes/'
---

# 222. Count Complete Tree Nodes

## Problem

Given a **complete** binary tree, count the number of nodes.

**Note:**

**Definition of a complete binary tree from** [**Wikipedia**](http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees)**:**  
 In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.

**Example:**

```text
Input: 
    1
   / \
  2   3
 / \  /
4  5 6

Output: 6
```

## Solution

### 1. level order traversal

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int countNodes(TreeNode* root) {
        if (root == nullptr) return 0;
        int count = 0;
        vector<TreeNode*> current({root});
        vector<TreeNode*> next;
        while (!current.empty()) {
            next.reserve(current.size() * 2);
            count += current.size();
            for (const auto n: current) {
                if (n->left != nullptr) next.push_back(n->left);
                else break;
                if (n->right != nullptr) next.push_back(n->right);
                else break;
            }
            current.clear();
            current.swap(next);
        }
        return count;
    }
};
```

### 2. Recursive

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int countNodes(TreeNode* root) {
        if (root == nullptr) return 0;
        TreeNode *left = root, *right = root;
        int hl = 0, hr = 0;
        while (left != nullptr) {
            left = left->left;
            ++hl;
        } 
        while (right != nullptr) {
            right = right->right;
            ++hr;
        } 
        if (hl == hr) return 2 * pow(2, hl - 1) - 1;
        return 1 + countNodes(root->left) + countNodes(root->right);
    }
    int pow(int n, int exp) {
        if (exp == 0) return 1;
        const int sqrt = pow(n, exp / 2);
        return (exp % 2 == 0) ? sqrt * sqrt : sqrt * sqrt * n;
    }
};
```

### 3. Recursive 2

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int countNodes(TreeNode* root) {
        if (root == nullptr) return 0;
        TreeNode *left = root->left, *right = root->right;
        int hl = -1, hr = -1;
        while (left != nullptr) {
            left = left->left;
            ++hl;
        } 
        while (right != nullptr) {
            right = right->left;
            ++hr;
        } 
        if (hl > 0 && hl == hr) return 2 * pow(2, hl) + countNodes(root->right);
        return 1 + countNodes(root->left) + countNodes(root->right);
    }
    int pow(int n, int exp) {
        if (exp == 0) return 1;
        const int sqrt = pow(n, exp / 2);
        return (exp % 2 == 0) ? sqrt * sqrt : sqrt * sqrt * n;
    }
};
```

* \#tree
* \#levelorder
* \#recursive

